# Ассемблер x86, часть 2

## Интерфейс системных вызовов

Способ выполнения системного вызова сильно отличается на разных платформах. На платформе x86 системный вызов
выполняется следующим образом:
* номер системного вызова помещается в регистр `%eax`
* параметры системного вызова помещаются в регистры `%ebx`, `%ecx`, `%edx` (в зависимости от их количества)
* выполняется инструкция `int $0x80`

Номера системных вызовов находятся в заголовочном файле `<asm/unistd_32.h>`. Например, чтобы считать один символ со стандартного
потока ввода нужно выполнить системный вызов:
```
char c;
int val = read(0, &c, sizeof(c));
```

соответствующий фрагмент программы на ассемблере будет выглядеть следующим образом:
```
#include <sys/unistd_32.h>
        .data
c:      .byte   0
        .text
        // прочие инструкции
        movl    $__NR_read, %eax
        movl    $0, %ebx
        movl    $c, %ecx
        movl    $1, %edx
        int     $0x80
        // в %eax будет возвращаемое значение read
```

системный вызов `exit(0);` на ассемблере запишется следующим образом:
```
        movl    $__NR_exit, %eax
        xorl    %ebx, %ebx
        int     $0x80
```

## Стандартное соглашение о передаче параметров

В программах, написанных на языках высокого уровня, все функции вызываются некоторым стандартным образом. Это соглашение
может варьироваться в зависимости от операционной системы, процессора и языка программирования. Программы на языке Си
в операционных системах Unix на архитектуре x86 используют по умолчанию следующее соглашение о вызовах:

* параметры вызываемой функции передаются через стек
* результат вызываемой функции возвращается в регистре %eax, либо в регистрах %eax, %edx, если возвращается 64-битное значение.
* параметры, размер которых меньше 4 байт (char, short), передаются как 4-байтовые значения
* параметры заносятся в стек в обратном порядке, таким образом в стеке параметры лежат в прямом порядке
* стек от параметров очищается после возврата из вызванной функции

Например, пусть в регистре `%esi` хранится адрес строки для вывода. Теперь, чтобы вывести на стандартный поток вывода строку
с помощью printf, 
```
        printf("Hello, %s\n", str); 
```

Потребуется следующий фрагмент на ассемблере:
```
        .text
msg1:   .asciz  "Hello, %s\n"
        // ...
        pushl   %esi            // заносим в стек содержимое %esi
        pushl   $msg1           // заносим в стек адрес строки msg1
        call    printf
        addl    $8, %esp        // чистим стек

