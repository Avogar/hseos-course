# Ассемблер x86, часть 4

## Компиляция программ без стандартной библиотеки Си

При компиляции программ с помощью драйвера gcc по умолчанию при компоновке программы подключается стандартная библиотека
языка Си libc. Частью стандартной библиотеки является код инициализации (start-up code), который
выполняет необходимую инициализацию стандартной библиотеки (например, создает стандартные потоки stdin, stdout, stderr),
а затем вызывает функцию `main`. Поэтому, если используется стандартная библиотека Си, точкой входа в программу
является функция `main`.

Чтобы отключить стандартную библиотеку можно использовать опцию `-nostdlib`. В этом случае к программе не подключается
код инициализации и код функций стандартной библиотеки. Программа остается "один на один" с операционной системой.
В этом случае точка входа в программу называется `_start` (на Linux). Ядро передает управление на точку `_start` не
как вызов подпрограммы, то есть для завершения программы нельзя использовать инструкцию `ret`. Для завершения
программы нужно использовать системный вызов `exit`.

Таким образом, чтобы скомпилировать 32-битную программу без стандартной библиотеки потребуется командная строка:
```
gcc -m32 -nostdlib prog.S -o prog
```

## Аргументы командной строки и переменные окружения

Перед передачей управления на точку входа `_start` ядро ОС размещает аргументы командной строки и переменные окружения в области памяти, отведенной под стек.
Если, например, верхняя граница адресного пространства, отведенного под стек, равна `0xc0000000`, то непосредственно ниже этой верхней границы будут размещены аргументы
командной строки и переменные окружения. В регистре `%esp` при входе в программу будет находиться текущая верхушка стека, растущего вниз. Начиная от значения `%esp`
на момент старта программы и до верхней границы адресного пространства, отведенного под стек, и будут располагаться аргументы командной строки и переменные окружения.

Так как адрес возврата на стеке отсутствует, по адресу `(%esp)` находится параметр `argc` --- 32-битное целое число, равное числу аргументов командной строки, включая имя программы.
По адресу `%esp + 4` начинается массив `argv` аргументов командной строки, который завершается нулевым указателем. Таким образом, `4(%esp)` --- это `argv[0]`, `8(%esp)` --- это `argv[1]`
`12(%esp)` --- это `argv[2]` и так далее. Если в регистр `%eax` поместить параметр `argc`, то по адресу `4(%esp, %eax, 4)` всегда будет находится нулевой указатель, обозначающий
конец аргументов командной строки. Следующий после него элемент --- это первая строка из массива переменных окружения. Массив переменных окружения завершается нулевым указателем.

Таким образом, в точке входа в программу значения указателей `argv` и `envp` могут быть вычислены следующим образом:

```
        mov     (%esp), %eax            // помещаем параметр argc в %eax
        lea     4(%esp), %ecx           // в регистре %ecx будет находиться адрес начала массива аргументов командной строки
        lea     8(%esp, %eax, 4), %edx  // в регистре %edx будет находиться адрес налала массива переменных окружения
```

Передать управление функции `main`, принимающей параметры argc, argv и envp можно будет следующим образом:

```
        and     $-16, %esp              // выравнивание стека
        push    %eax                    // для выравнивания области параметров по 16 байт
        push    %edx                    // envp
        push    %ecx                    // argv
        push    %eax                    // argc
        call    main
        add     $16, %esp
```

## Интерфейс системных вызовов

Способ выполнения системного вызова сильно отличается на разных платформах. На платформе x86 системный вызов
выполняется следующим образом:
* номер системного вызова помещается в регистр `%eax`
* параметры системного вызова помещаются в регистры `%ebx`, `%ecx`, `%edx`, `%esi`, `%edi` (в зависимости от их количества)
* выполняется инструкция `int $0x80`

Номера системных вызовов находятся в заголовочном файле `<asm/unistd_32.h>`. Например, чтобы считать один символ со стандартного
потока ввода нужно выполнить системный вызов:
```c
char c;
int val = read(0, &c, sizeof(c));
```

соответствующий фрагмент программы на ассемблере будет выглядеть следующим образом:
```gas
#include <asm/unistd_32.h>
        .data                   // размещаем данные
c:      .byte   0               // c - это глобальная переменная размера один байт (char)
        .text                   // начинаем секцию кода
        // ...
        movl    $__NR_read, %eax // или $3, %eax, если заголовочный файл не найден
        movl    $0, %ebx        // первый аргумент (0 - стандартный поток ввода) в %ebx
        movl    $c, %ecx        // второй аргумент (адрес переменной c) в %ecx
        movl    $1, %edx        // третий аргумент (размер переменной c) в %edx
        int     $0x80
        // в %eax будет возвращаемое значение read
```

системный вызов `exit(0);` на ассемблере запишется следующим образом:
```gas
        movl    $__NR_exit, %eax
        xorl    %ebx, %ebx
        int     $0x80
```

если файл `<asm/unistd_32.h>` недоступен, можно использовать численные значения:
```gas
#define __NR_exit 1
#define __NR_fork 2
#define __NR_read 3
#define __NR_write 4
```

## Некоторые системные вызовы

Для написания программ нам потребуются следующие простейшие системные вызовы. Ниже будет дано краткое описание, полностью
эти системные вызовы будут рассмотрены далее в соответствующих разделах курса.

```
ssize_t read(int fd, void *ptr, size_t size);
```

Чтение из потока. Для чтения со стандартного потока ввода значение `fd` указывается равным 0. `ptr` - адрес, по которому
будут размещены считанные данные, `size` - размер буфера для чтения. `read` возвращает:
* -1 в случае ошибки чтения;
* 0 в случае достижения конца файла;
* число действительно считанных байт данных (оно не больше чем размер `size`, но не обязано быть ему равным).

```
ssize_t write(int fd, const void *ptr, size_t size);
```

Запись в поток. Для записи на стандартный поток вывода значение `fd` указывается равным 1. `ptr` - адрес, по которому
размещаются данные для записи, `size` - размер записываемых данных. `write` возвращает:
* -1 в случае ошибки записи;
* число записанных байт данных (не больше чем `size`, но не обязано быть ему равным).
Пока мы будем предполагать, что успешно записываются все данные из буфера `ptr`.

```
void exit(int code);
```

Завершение программы с кодом возврата `code`. Обратите внимание, что в стандартной библиотеке Си функция-обертка для
системного вызова exit называется `_exit`. Тем не менее, константа номера системного вызова называется `__NR_exit`.

```
void *brk(void *newbrk);
```

Установить новый адрес конца кучи в программе. `newbrk` - новый адрес. Системный вызов возвращает новый адрес конца кучи.
Чтобы получить текущий адрес конца кучи нужно задать параметр `newbrk` равным `NULL`.
Обратите внимание, что функция-обертка стандартной библиотеки Си имеет другой прототип.

## Позиционно-независимый код

В примере вывода строки на стандартный поток вывода инструкция `push $msg1` заносит в стек **адрес** в памяти,
по которому размещается строка "Hello". При компоновке программы в исполняемый модуль будет получен такой фрагмент исполняемого файла:
```
08048460 <func>:
 8048460:	56                   	push   %esi
 8048461:	68 50 84 04 08       	push   $0x8048450
 8048466:	e8 a5 fe ff ff       	call   8048310 <printf@plt>
 804846b:	83 c4 08             	add    $0x8,%esp
 804846e:	c3                   	ret    
```

(для получения ассемблерного листинга использовалась команда `objdump --disassemble FILE`)

В этом фрагменте в инструкции вызова `call` для получения адреса, на который нужно переходить, испольуется смещение
`0xfffffea5` (байты a5 fe ff ff), а для загрузки в стек адреса строки, используется абсолютный адрес `0x08048450`
(байты 50 84 04 08).

Если мы заходим разместить исполняемый файл в памяти, начиная с другого адреса, а не с адреса `0x08048034`, инструкция `call`
останется без изменений (так как смещение не изменится при перемещении файла по памяти), а инструкция `push` потребует модификации.
Машинный код, настроенный на работу по фиксированным адресам в памяти, называется **неперемещаемым** (или позиционно-зависимым).

Такой код малопригоден для разделяемых библиотек, так как одна и та же библиотека может располагаться по разным адресам
в адресном пространстве разных процессов.

В **позиционно-независимом** (PIC) коде запрещено использование абсолютных адресов. Все адреса глобальных переменных и областей данных
должны вычисляться относительно текущего положения исполняемого кода.

Один из возможных способов реализации PIC-кода описан ниже.

Для получения текущей позиции в коде используется идиома:
```gas
        call    l1
l1:     popl    %eax
```

То есть мы "вызываем" следующую инструкцию программы, помеченную `l1`.
При этом в стек будет занесен адрес возврата (та же самая инструкция, помеченная `l1`), и затем будет
выполнен переход на саму же инструкцию, помеченную `l1`. После этого адрес инструкции достается из стека
с помощью инструкции `popl`.

```gas
        .text
msg1:   .asciz  "Hello, %d!\n"
        .align  16
        .global func
func:
        pushl   %esi            /* сразу заносим в стек второй аргумент printf */
        call    l1              /* получаем адрес, по которому размещаемся в памяти */
l1:     popl    %eax
        addl    $msg1-l1, %eax  /* прибавляем к адресу l1 смещение msg1 относительно l1 */
        pushl   %eax            /* заносим в стек получившийся абсолютный адрес */
        call    printf
        addl    $8, %esp        /* чистим стек */
        ret
```

## Косвенные переходы и вызовы подпрограмм

Для реализации операторов типа `switch`, или для реализации таблиц виртуальных функций, полезна возможность косвенного перехода или вызова подпрограммы.
Например, инструкция
```gas
        jmp     *%eax
```
выполнит переход по адресу, который располагается в регистре `%eax`, а инструкция `call *%eax` выполнит аналогичный вызов подпрограммы.

Предположим, что в регистре `%eax` передано некоторое значение от 0 до 3. Нам нужно перейти на метку `D0`, `D1`, `D2`, `D3` в зависимости о значения `%eax`.
```gas
        movl    jmptab(,%eax,4), %eax   // загружаем адрес из таблицы адресов
        jmp     *%eax                   // косвенный переход
jmptab: .int    D0, D1, D2, D3          // записываем адреса меток
```
