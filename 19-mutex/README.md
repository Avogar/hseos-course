# Нити (threads)

## Атомарность работы с памятью

На всех современных процессорах (x86, x64, Itanium, SPARC, ARM, PowerPC) операции чтения из памяти
и записи в память натурально-выравненных значений размера не более машинного слова
атомарны. Точную информацию об этом можно получить в руководстве по соответствующей архитектуре.
Таким образом, можно предполагать, что на этих архитектурах чтение/запись 32-битных значений, адреса
которых выравнены по границе 4 байт атомарны.

Атомарность чтения и записи означает, что в случае одновременного чтения одним ядром и записи другим ядром значения
по одному и тому же адресу, 32-битное значение не "рассыпется на куски" частично старого, а частично нового значения. Операция
чтения вернет либо старое значение ячейки памяти, либо новое значение ячейки памяти.

Такая семантика чтения и записи явно и неявно используется в большом объеме существующего программного кода. И, скорее всего,
такая семантика сохранится и в будущем.

Но, строго говоря, <b>с точки зрения стандартов Си и Си++ такое предположение некорректно</b>! С точки зрения стандарта
по умолчанию никакие операции работы с памятью не являются атомарными. Мы должны использовать специальные типы данных (например
`std::atomic`) и операции с ними.

И, конечно же, "наивное" предположение об атомарности будет неверным для операций, которые требуют чтения из ячейки памяти
и записи в нее же, и для типов, больших чем машинное слово. То есть "наивная" операция `a += 2` или `++a` для целого типа
или операция присваивания для типа `long long` на 32-битной платформе <b>не будет атомарна никогда</b>.

Ключевое слово `volatile` запрещает хранение переменных на регистрах процессора и перестановку порядка выполнения операций с `volatile`
переменными друг относительно друга, но не делает работу с переменной атомарной. В общем случае ключевое слово `volatile` само по себе <b>нельзя
использовать для синхронизации нитей</b>.

## Модель памяти

Современные оптимизирующие компиляторы могут выполнять достаточно сложные преобразования программы, если алгоритм оптимизации программы
сочтет это выгодным для повышения производительности. Компилятор может выносить повторяющиеся вычисления из тела цикла,
хранить переменные на регистрах, переставлять независимые операции чтения и записи местами.

Современные процессоры при выполнении программы тоже могут выполнять перестановку доступов к памяти, выполнять спекулятивные загрузки и
другие оптимизации. Кроме того, каждое процессорное ядро имеет свой кеш и реализует сложные протоколы взаимодействия кешей
и сохранения значений из кеша в оперативную память.

Все это приводит к тому, что <i>наблюдаемый</i> порядок изменения значений в памяти в одной нити может отличаться от
<i>наблюдаемого</i> порядка изменения значений в памяти в другой нити.

Например, если в одной нити выполняется фрагмент:
```
y = 0;
x = 0;
// ...
x = 1;
y = 2;
// ...
x = 3;
```

а в другой нити фрагмент:
```
if (y == 2) {
  z = x;
}
```

Переменная `z` вполне может получить значение 0, если компилятор или процессор поменял местами присваивания `x = 1` и `y = 2`.

<b>Модель памяти</b> определяет, как может и как не может изменятся порядок выполнения операций доступа к памяти в разных случаях
выполнения программы. Современные стандарты языков Си и Си++ (C11 и C++14) имеют общую модель памяти.

## atomic-типы

Для обеспечения атомарности операций с памятью и спецификации разрешенных оптимизаций при работе с памятью Си++ предлагает
шаблонный класс `std::atomic<T>`. Методы этого типа гарантируют атомарность доступа к переменной и определенный порядок
выполнения операций с памятью.

В качестве типа `T` можно использовать любой тип данных, но не для любого типа данных компилятор сможет сгенерировать
машинный код, который не будет использовать мьютексы. Например, не стоит ожидать, что работа с типом
`std::atomic<long long>` на 32-битной платформе не потребует операций с мьютексом. Но разумно ожидать, что работа с типами
`std::atomic<bool>`, `std::atomic<int>`, `std::atomic<char *>` (или любой указатель, на самом деле) будет выполняться
с помощью специализированных инструкций процессора.

Чтобы определить, требуется ли блокировка для работы с `atomic<T>` можно использовать метод `is_lock_free`, например:
```
std::atomic<long long> llv{0};

if (!llv.is_lock_free()) {
    std::cerr << "so sad" << std::endl;
}
```

### std::memory_order

Чтобы специфицировать, как атомарная операция работы с памятью может влиять на находящиеся вокруг нее обычные операции работы с
памятью используются константы, определенные в типе `std::memory_order`.

Некоторые значения констант перечислены ниже:

`memory_order_relaxed` - атомарная операция не накладывает никаких ограничений на операции работы с памятью вокруг нее. Требуется только
атомарность самой операции.

`memory_order_acquire` - запрещает перестановку операций работы с памятью вперед данной операции. То есть, если в тексте программы
операция обращения к памяти находится после атомарной операции с этим флагом, то и при выполнении программы она будет выполнена позднее.
Это гарантирует, что все записи в память, которые в других нитях стояли раньше атомарной операции освобождения (см. ниже), будут видимы
в текущей нити.

`memory_order_release` - запрещает перестановку операций работы с памятью после данной операции. То есть, если в тексте программы
операция обращения к памяти находится перед атомарной операции с этим флагом, то и при выполнении программы она будет выполнена ранее.
Это гарантирует, что все записи в память будут видны другим нитям, которые выполняют операцию с флагом `memory_order_acquire`.

Флаги `memory_order_acquire` и `memory_order_release` являются дополняющими друг друга. Операция `lock` обычно выполняется
с флагом `memory_order_acquire`, а операция `unlock` - c флагом `memory_order_release`.

`memory_order_acq_rel` - и `memory_order_acquire`, и `memory_order_release` одновременно. То есть нельзя переставлять неатомарные
операции относительно такой атомарной операции. Тем не менее, если мы рассмотрим сами атомарные операции, то их наблюдаемый
в разных нитях относительный порядок может различаться.

`memory_order_seq_cst` - это самый строгий порядок выполнения операций с памятью. Не только гарантируется порядок неатомарных
операций вокруг атомарных, но и все атомарные операции будут видимы всем нитям в одном и том же порядке. Этот порядок выполнения
операций задается по умолчанию.

### Операции с atomic-типами

`void std::atomic<T>::store(T value, std::memory_order order = std::memory_order_seq_cst);` 
Эта операция сохраняет в памяти значение `value`, параметр `order` задает модель записи.
Например,
```
std::atomic<bool> lock{true};

// ...
lock.store(true, std::memory_order_release);
```

`T std::atomic<T>::load(std::memory_order order = std::memory_order_seq_cst);`
Загружает значение из памяти и возвращает результат.
Пример:
```
std::atomic<Data *> instance = nullptr;

auto local = instance.load(std::memory_order_relaxed);
```

`T std::atomic<T>::exchange(T newval, std::memory_order order = std::memory_order_seq_cst);`
Записывает в память значение `newval` и одновременно считывает старое значение, которое возвращается в качестве результата.
Например,
```
std::atomic<bool> lock{true};

auto oldval = lock.exchange(false, std::memory_order_acquire);
```

Про другие операции можно прочитать в [документации](http://en.cppreference.com/w/cpp/atomic/atomic).

## Мьютексы

[man 3 pthread_mutex_lock](http://linux.die.net/man/3/pthread_mutex_lock)

Если одни и те же данные используются одновременно более, чем в одном потоке, и хотя бы в одном из этих потоков модифицируются, может возникнуть "состояние гонки" (race condition), когда появляется возможность для какого-либо потока обнаружить данные частично модифицированными, т.е. в неконсистентном виде. Операция с данными, при которой невозможно состояние гонки, называется атомарной.

Самый простой (но часто не самый практичный) способ обеспечить атомарность операции - при помощи мьютекса (mutual exclusion, взаимного исключения) гарантировать, что к данным в одно и то же время имеет доступ не больше одного потока.

```c
// хотим гарантировать, что эти два счётчика модифицируются одновременно, 
// то есть никакое чтение не должно увидит эту пару в состоянии, 
// когда один из счётчиков модифицирован, а другой - ещё нет
volatile sig_atomic_t counter0 = 0;
volatile sig_atomic_t counter1 = 0;
pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;

// оба счётчика увеличиваются одновременно
void add_counters(int add0, int add1) {
    pthread_mutex_lock(&counter_mutex);
    counter0 += add0;
    counter1 += add1;
    pthread_mutex_unlock(&counter_mutex);
}

// возвращаем консистентные значения счётчиков
void read_counters(int* cnt0, int* cnt1) {
    pthread_mutex_lock(&counter_mutex);
    *cnt0 = counter0;
    *cnt1 = counter1;
    pthread_mutex_unlock(&counter_mutex);
}
```

## Условные переменные

