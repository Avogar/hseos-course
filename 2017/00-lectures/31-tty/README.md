# Последовательный интерфейс

Вернемся к обсуждению взаимодействия компьютера (процессора) и внешних устройств.
С точки зрения организации взаимодействия на физическом уровне, то есть на уровне электрических проводов
или радиосигналов или другой передающей среды, сигнал может передаваться либо последовательно, либо параллельно.
При параллельной передаче данных от отправителя к получателю одновременно передаются несколько бит данных.
Для этого потребуется несколько паралельных электрических проводов, соединяющих отправителя и получателя информации.
При последовательной передаче данных биты сообщения передаются один за одним через передающую среду.

Параллельная передача данных используется для высокоскоростной передачи на небольшие расстояния, как правило, не выходящие за пределы
материнской платы компьютера. Ранее использовались параллельные интерфейсы для связи компьютера и переферийных устройств, такие как SCSI, IDE, ParPort,
но в настоящее время они все оказались вытесненными высокоскоростными последовательными интерфейсами, такими как SATA, USB и прочими.
Присущие параллельным интерфейсам недостатки, такие как сложность разводки проводников на печатной плате или большое количество проводников в кабеле,
взаимовлияние параллельно идущих проводников, рассинхронизация параллельно идущих проводников ограничивают максимальную длину кабеля и максимальную скорость работы.
Эти недостатки отсутствуют у последовательных интерфейсов.

## UART

Существует много разных последовательных (serial) физических интерфейсов и протоколов взаимодействия, таких как USB, SATA, FireWire и т. п.
Мы остановимся на семействе физических интерфейсов и протоколов, обобщенно называющихся UART (Universal Asynchronous Receiver/Transmitter -
Универсальный асинхронный приемополучатель). Асинхронность в названии термина обозначает, что сигнал синхронизации (тактовый сигнал) не передается
по линии от отправителя и получателя. Отправитель и получатель синхронизуются при отправке каждой порции данных (обычно 8 бит).

Самый простой (симплексный)
UART интерфейс состоит из двух проводов - одного для передачи данных только в одну сторону, и второй для установки уровня логического нуля (GND).
Типичный UART состоит из трех контактов: Rx, на котором принимаются данные, Tx, на котором данные отправляются, и GND для поддержания уровня логического нуля.
Двусторонний UART может работать в полудуплексном или полнодуплексном режиме в зависимости от оконечного оборудования и программного обеспечения.

Таким образом, когда говорят о каналах связи, симплексный режим передачи обозначает, что данные могут передаваться только в одном направлении от отправителя к получателю.
Дуплексный режим обозначает, что обе стороны могут обмениваться данными. При этом полнодуплексный режим означает, что стороны обмена могут одновременно принимать и отправлять
данные, то есть в момент времени, когда с контакта Rx считывается входное логическое значение 0 или 1, на контакте Tx устанавливается выходное логическое значение.
Полудуплексный режим означает, что в каждый момент времени выполняется передача данных не более чем в одну сторону, то есть либо одна сторона передает данные другой стороне, либо наоборот,
но не одновременно.

Чтобы соединить две стороны с помощью дуплексного UART нужно выход Rx одной стороны соединить с выходом Tx другой стороны и наоборот, а выход GND соединить друг с другом.

![UART connection](images/uart.png "UART connection")

Понятно, что обе стороны должны быть электрически совместимы друг с другом и иметь один уровень логического нуля (земли), то есть, если попробовать соединить один UART-интерфейс
с уровнем логической единицы 12 вольт с UART интерфейсом с уровнем логической единицы 3.3 вольта, то ничего хорошего не произойдет. Кроме того, проводники, соединяющие стороны, сами имеют
свои электрические характеристики (сопротивление, емкость, индуктивность), и поэтому если мы возьмем слишком длинный проводник и маленькое напряжение логической единицы сигнал может просто не дойти
из-за падения напряжения в проводнике. Физические характеристики обменивающихся сторон и передающей среды описываются на физическом уровне стандарта взаимодействия. Например,
стандарт RS232 задает уровень логической единицы в диапазоне от -15V до -3V, а уровень логического нуля в диапазоне от 3V до 15V и задает максимальную емкость передающего кабеля такой,
что максимальная длина типичного RS232 кабеля равна 15 метрам. Если мы будем соединять два UART устройства на любительских микрокомпьютерах (Arduino, Raspberry Pi), то в данном
случае уровень логического нуля будет соответствовать 0V (то есть общей земле), уровень логической единицы будет равен 5V, а длина соединяющих проводников - не более нескольких дециметров.

Передача данных по UART выполняется следующим образом. Обе стороны некоторым образом договариваются о скорости передачи данных, которая измеряется в битах в секунду (бодах).
Если скорость равна, например, 300 бод, то время передачи одного бита равно Tb = 1/300 c (3333 мкс - микросекунды).
Нормально на линии передачи данных выставлено напряжение логической единицы, которое поддерживается все время, когда у сторон включен UART-интерфейс.
Если передатчик хочет начать передачу данных, он на время передачи одного бита устанавливает на линии уровень логического нуля (стартовый бит). Затем передаются биты данных начиная от младшего,
для передачи каждого бита соответствующий логический уровень устанавливается на время Tb. В конце передачи данных может передаваться бит паритета, после которого на линии передачи
данных на время передачи одного или двух битов выставляется уровень логической единицы (стоповые биты). На этом отправка одной "порции" данных считается завершенной.

![UART transmission](images/max_exp_uart.png "UART transmission")

Прием данных выполняется следующим образом. Приемник отслеживает уровень сигнала на входе Rx. В момент смены уровня сигнала с логической единицы на логический нуль
начинается отсчет времени приема данных. Приемник пропускает интервал времени 1.5 Tb, затем замеряет уровень сигнала на входе Rx через интервал времени Tb. Когда приемник
считал со входной линии стоповые биты передача считается завершенной, и приемник переходит к отслеживанию момента начала следующей передачи. При приеме данных возникают две технические проблемы.
Во-первых, приемник может "опоздать" с определением момента начала передачи. То есть смена логической единицы на логический нуль будет обнаружена не в момент времени T0,
а в момент времени T0 + dt. Здесь мы будем пока игнорировать переходные процессы в проводнике и конечность скорости распространения сигнала, так как UART не работает на скоростях,
на которых эти эффекты оказывают ощутимое воздействие на передачу данных. Во-вторых, скорость работы приемника может отличаться от скорости работы передатчика, даже если они
согласовали скорость передачи. Например, при согласованной скорости передачи 300 бод передатчик фактически передает данные со скоростью 310 бод, а приемник фактически принимает
данные со скоростью 290 бод. Эти проблемы могут привести к ошибкам при передаче данных. Чтобы исключить это, приемник должен проверять состояние входной линии достаточно часто,
как минимум со скоростью в два раза больше, чем скорость передачи данных. Кроме того, рассогласование отсчетов времени не должно превысить половину времени передачи одного бита
за время передачи данных. Если мы предположим, что данные передаются в формате один стартовый бит, 8 бит данных и один стоповый бит (всего 10 бит), то рассогласование скорости передатчика и приемника
не должно быть больше 5%.

При приеме данных целостность принятых данных может контролироваться с помощью бита паритета (parity bit). Бит паритета передается после битов данных перед стоповыми битами.
Если бит паритета работает в режиме четного паритета (even parity), отправитель устанавливает значение бита паритета как исключающее или всех бит данных, то есть бит паритета равен 1,
если в передаваемых данных было нечетное число единичных бит, и 0 в противном случае. На принимающей стороне вычисляется побитовое исключающее или всех битов данных и бита паритета.
Результат операции должен быть равен 0.
Для нечетного паритета бит паритета устанавливается таким образом, что при приеме результатом вычисления побитового исключающего или всех битов данных и бита паритета будет 1.
Бит паритета не является обязательным в отличие от стартового и стопового бита. Бит паритета позволяет выявлять, но не исправлять только изменение значения в одиночном бите.
Более сложный контроль целостности данных может выполняться на более высоких уровнях передачи данных.

Таким образом, чтобы приемник мог правильно декодировать электрические сигналы, посылаемые передатчиком, приемник и передатчик должны иметь одинаковые настройки параметров передачи данных UART:
* Скорость передачи данных в бодах. Она, вообще говоря, может быть любой, но все реализации предоставляют выбор из предопределенного набора скоростей передачи. Наиболее часто используемые значения:
9600, 38400, 115200 бод.
* Количество пересылаемых бит данных, от 5 до 8.
* Тип паритета: отсутствует (N), то есть бит паритета вообще не передается; четный (E); нечетный (O).
* Число стоп-битов: один или два.

В краткой форме настройки передачи данных записываются в виде `9600 8N1`, то есть скорость - 9600 бод, 8 бит данных, без бита паритета, один стоп-бит.
Эти настройки относятся к канальному уровню протокола взаимодействия сторон.

## Использование UART

Принцип последовательной передачи данных UART широко используется для подключения внешнего оборудования. Например, для модемов, GPS-приемников, сканеров штрих-кодов, то есть,
когда не требуется высокая скорость приема и передачи данных.

Иногда физическое подключение к UART выполняется с помощью трех контактов с одной и другой стороны, соединенных проводами. Такое подключение может использоваться как
интерфейс для отладки или служебного доступа к аппаратуре. На фотографии ниже показано соединение по UART двух микрокомпьютеров: Orange Pi и Rasperry Pi.
Микрокомпьютер Raspberry Pi выступает в роли терминала, то есть будет отображать полученную по последовательному порту информацию на свою консоль, а введенные пользователем
данные будут отправляться на последовательный порт. Таким образом можно подключиться к работающему микрокомпьютеру даже в случае, если у него не активированы сетевые адаптеры,
недоступна клавиатура и экран.

UART реализован в интерфейсе стандарта RS-232. Стандарт был опубликован в 1960 году и используется в промышленной автоматике до сих пор. Стандарт определяет физическую среду
передачи данных, то есть уровни напряжений, допустимые физические характеристики передающей среды. Кроме того стандарт определяет разные типы разъемов для подключения кабеля
к устройству. Например, на фотографии ниже показан 9-пиновый разъем DE-9.

![DE-9 connector](images/rs232.jpg "DE-9 connector")

Разъемы DE-9 присутствовали на всех компьютерах вплоть до конца 90-х годов. К ним подключались модемы, сканеры, мыши. В настоящее время в качестве разъема для подключения
периферийных устройств используется USB. Большинство периферийных устройств, подключаемых к бытовым компьютерам, также теперь используют интерфейс USB. Однако чтобы
подключить устройство по стандарту RS-232 можно использовать конверторы RS-232 в USB, например, показанные на фотографии ниже.

![RS-232 to USB converter](images/rs232-to-usb.jpg "RS-232 to USB converter")

Для подключения к отладочному UART-интерфейсу обычно используется конвертер USB в UART, например, показанный на фотографии ниже.

![Serial to USB converter](images/serial-to-usb.jpg "Serial to USB converter")

В любом случае при подключении такого конвертера в разъем USB на компьютере создается виртуальный последовательный порт, то есть внешнее устройство, которое
с точки зрения интерфейса использования ведет себя как последовательный порт, но обмен данными с этим виртуальным устройством преобразовывается ядром
в обмен данными с USB-конвертером, который на своей стороне преобразует обмен данными по USB в обмен данными по RS-232 или UART. То есть USB-интерфейс будет
невидимым с точки зрения интерфейса использования мостом между компьютером и последовательным портом.

## Терминалы

Одним из основных устройств, которые подключались к компьютерам в 70- и 80-е годы были терминалы. Терминал представлял собой клавиатуру и экран, который обычно
поддерживал отображение текста в окне с 25 строками и 80 столбцами. Существовали также и терминалы, которые поддерживали отображение графики. Терминал подключался
к компьютеру по интерфейсу RS-232, и к одному компьютеру могли подключаться десятки таких терминалов. Пользователи, работающие за терминалами, подключенными
к одному компьютеру, разделяли ресурсы одного компьютера. Фотография терминала VT-320 приведена ниже.

![VT-320](images/vt320.jpg "VT-320")

Терминалы фирмы DEC (Digital Equipment Corporation) семейства VT были самыми популярными. Модель DEC VT-220 была продана более чем в одном миллионе экземпляров,
что сравнимо с числом персональных компьютеров, проданных в те же годы. Терминалы DEC очень сильно повлияли на развитие Unix-систем. Одним из самых
распространенных микрокомпьютеров в 80-е годы был микрокомпьютер DEC VAX, к которому, естественно, подключались терминалы семейства DEC VT. Помимо "штатной"
операционной системы VAX VMS на микрокомпьютерах VAX была распространена BSD Unix, особенно в университетах. Поэтому большая часть разработки операционной системы BSD Unix
выполнялась на VAX.

Одной из основных программ на современных персональных компьютерах, работающих под управлением Linux в графическом интерфейсе, является программа-эмулятор терминала.
Программа отображает на экране текстовое окно по умолчанию стандартного размера 25 строк на 80 столбцов. Эмулятор терминала отправляет ввод с клавиатуры программе, работающей
на данном терминале, а вывод программы отображает в окно на экране. Все эмуляторы терминалов, начиная от xterm и его производных (konsole, gnome-terminal, xfce4-terminal и т. д.),
эмулируют работу алфавитно-цифрового терминала, основанного именно на DEC VT-220. Терминалы, подключаемые по последовательному интерфейсу, до сих пор поддерживаются в Linux. Если подключить
к работающей системе терминал из 80-х годов, Linux прекрасно будет с ним работать. Более того, Linux поддерживает консоль (то есть "самый главный" терминал) на последовательном порту,
что полезно, если к компьютеру не подключены ни клавиатура, ни монитор.

Терминал передает информацию о нажатой клавише компьютеру, к которому он подключен. Для алфавитно-цифровых и управляющих клавиш передается соответствующий код ASCII.
Например, нажатая на клавиатуре цифра 0 передается в компьютер как 48 (ASCII-код символа '0'), комбинация клавиш Ctrl-C передается в компьютер как 3, и так далее.
Для специальных клавиш, таких как клавиши управления курсором, Fn, INS, DEL и т. п. в компьютер передаются так называемые ESC-последовательности, кодирующие эту клавишу.
ESC-последовательность - это последовательность байт, которая начинается с кода 27 (восьмеричное 33), соответствующего в кодировке ASCII управляющему символу ESC.
Так, при нажатии на клавишу "стрелка вверх" в компьютер будет передана последовательность трех байт `ESC '[' A`.

Терминал отображает данные, получаемые от компьютера, при этом терминал специальным образом обрабатывает ESC-последовательности, с помощью которых можно управлять отображением
символов на экране или режимом работы терминала. Например, если передать на терминал последовательность четырех байт `ESC '[' '2' 'J'`, экран будет очищен.

Как было отмечено выше, современные эмуляторы терминалов работают точно также, то есть при нажатии специальных клавиш в программу передается ESC-последовательность,
кодирующая эту клавишу, и при выводе эмуляторы терминалов специальным образом обрабатывают ESC-последовательности.

Существовало и существует большое количество как аппаратных терминалов, так и программных эмуляторов. Они могут отличаться друг от друга своей системой команд
и другими характеристиками. Чтобы сделать программы, работающие с терминалами, максимально гибкими, свойства терминалов описываются в специальной базе,
называемой terminfo. В современных операционных системах она размещается, как правило, в каталог /usr/share/terminfo. Каждому типу терминала соответствует отдельный файл.
Например, описание терминала `vt220` находится в файле `/usr/share/terminfo/v/vt220`. Получить описание терминала в текстовом виде можно c помощью команды `infocmp`,
например,
```
[cher@localhost ~]$ infocmp vt220
#	Reconstructed via infocmp from file: /usr/share/terminfo/v/vt220
vt220|vt200|dec vt220,
	am, mc5i, mir, msgr, xenl, xon,
	cols#80, it#8, lines#24, vt#3,
	acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
	bel=^G, blink=\E[5m, bold=\E[1m, clear=\E[H\E[J, cr=^M,
	csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H,
	cud=\E[%p1%dB, cud1=^J, cuf=\E[%p1%dC, cuf1=\E[C,
	cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,
	dch=\E[%p1%dP, dch1=\E[P, dl=\E[%p1%dM, dl1=\E[M,
	ech=\E[%p1%dX, ed=\E[J, el=\E[K, el1=\E[1K, enacs=\E)0,
	flash=\E[?5h$<200/>\E[?5l, home=\E[H, ht=^I, hts=\EH,
	ich=\E[%p1%d@, if=/usr/share/tabset/vt100,
	il=\E[%p1%dL, il1=\E[L, ind=\ED,
	is2=\E[?7h\E[>\E[?1l\E F\E[?4l, kbs=^H, kcub1=\E[D,
	kcud1=\E[B, kcuf1=\E[C, kcuu1=\E[A, kdch1=\E[3~, kf1=\EOP,
	kf10=\E[21~, kf11=\E[23~, kf12=\E[24~, kf13=\E[25~,
	kf14=\E[26~, kf17=\E[31~, kf18=\E[32~, kf19=\E[33~,
	kf2=\EOQ, kf20=\E[34~, kf3=\EOR, kf4=\EOS, kf6=\E[17~,
	kf7=\E[18~, kf8=\E[19~, kf9=\E[20~, kfnd=\E[1~,
	khlp=\E[28~, kich1=\E[2~, knp=\E[6~, kpp=\E[5~,
	krdo=\E[29~, kslt=\E[4~, lf1=pf1, lf2=pf2, lf3=pf3, lf4=pf4,
	mc0=\E[i, mc4=\E[4i, mc5=\E[5i, nel=\EE, rc=\E8, rev=\E[7m,
	ri=\EM, rmacs=\E(B$<4>, rmam=\E[?7l, rmir=\E[4l,
	rmso=\E[27m, rmul=\E[24m, rs1=\E[?3l, sc=\E7,
	sgr=\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p4%t;5%;%?%p1%p3%|%t;7%;m%?%p9%t\E(0%e\E(B%;$<2>,
	sgr0=\E[m\E(B, smacs=\E(0$<2>, smam=\E[?7h, smir=\E[4h,
	smso=\E[7m, smul=\E[4m, tbc=\E[3g, u6=\E[%i%d;%dR,
	u7=\E[6n, u8=\E[?%[;0123456789]c, u9=\E[c,
```

Идентификатор типа терминала, используемого в данной сессии пользователя, задается с помощью переменной окружения `TERM`:
```
[cher@localhost ~]$ echo $TERM
xterm-256color
```

Именно эта переменная используется программами, работающими с экраном и клавиатурой специальным образом (например,
редакторы vim, emacs, nano отображают текст для редактирования на экране и поддерживают навигацию по тексту с помощью
клавиш управления курсором и т. д.). Значение переменной `TERM` используется для получения свойств терминала
из базы terminfo и настройки на особенности терминала. Если изменить переменную окружения `TERM` неправильно,
эти программы могут отображать данные неправильно или вообще перестанут работать.
