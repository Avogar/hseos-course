# Цель семинара
  * Понять: общую схему трансляции и запуска программ в операционной системе; схему работы отладчика.
  * Научиться: компиляции и сборке программ на C++, состоящих из одного или нескольких файлов; отладке программ в среде Linux.

# Содержание семинара
  1. Исполняемый файл, запуск исполняемого файла операционной системой.
  2. Компиляция .cpp -> .o. Флаги компиляции.
  3. Препроцессор, заголовочные файлы, директива #include.
  4. Компоновка (линковка) исполняемого файла. Использование динамических и статических библиотек.
  5. Отладка программы с помощью gdb. Точки останова (breakpoints). Способы запуска отладчика.
  6. ~~Гадание~~ Отладка по coredump.

# Теоретическая справка



# Задание
0. Склонируйте репозиторий git@github.com/hseos/sem-03.git.

1. В файле `bc.cpp` реализован калькулятор арифметических выражений. Он представляет из себя простой REPL (link to wiki).
 Сначала по входной строке строится дерево разбора (функция `Parse()`), затем это дерево вычислется (фукция `Eval()`).
 В файле `ast.h` находятся определения структур, из которых состоит дерево.

 Скомпилируйте файл `bc.cpp` и запустите получившийся исполняемый файл. Вычислите значение выражения 1 + 2 * 3.

 *Note: В калькуляторе используется класс `std::unique_ptr`, появивившийся в стандарте c++11. Чтобы файл скомпилировался,
 нужно указать компилятору опцию `-std=c++11`.*

 *Note: Для выхода из калькулятора используйте сочетание клавиш Ctrl+C. Это сочетание убивает запущеный в терминале процесс.*

2. Логику работы необходимо отделить от обработки входных данных и вывода результата и выделить в отдельный файл.
Поместите функцию `Eval()` в файл `eval.cpp`, и прототип этой функции в `eval.h`.

Поместите класс Evaluator в файл evaluator.h, а определение его методов --- в файл evaluator.cpp (подключите в нем необходимые заголовочные файлы).
Скомпилируйте файл evaluator.cpp в объектный файл, добейтесь отсутствия ошибок компиляции. (Подсказка: вам понадобится изменить файл ast.h).
Попробуйте повторить п.1. Завершилась ли компиляция успешно?

3. Скомпилируйте файл my_bc.cpp в объектный файл. Слинкуйте объектные файлы в исполняемый файл и запустите его.

4. В файле bc_test.cpp находятся юнит-тесты на Evaluator и Parser. Тесты используют библиотеку gtest.
Скомпилируйте юнит-тесты, используя статическую версию библиотеки (файл gtest/libgtest.a). Запустите тесты и убедитесь, что они проходят (PASSED). Посмотрите размер получившегося исполняемого файла bc_test. Удалите статическую библиотеку, запустите исполняемый файл.
Скомпилируйте юнит-тесты, используя динамическую версию библиотеки (файл gtest/libgtest.so). Снова запустите тесты. Как изменился размер получившегося исполняемого файла? Почему? Удалите динамическую библиотеку и попробуйте запустить исполняемый файл. Что произошло и почему?


5. Запустите исполняемый файл и вычислите значение выражения 42 / 0. Что произошло с программой? Запустите программу под отладчиком и снова вычислите значение выражения 42 / 0. Можете ли Вы найти строку программы, в которой происходит ошибка?

6. Найдите строку программы, в которой происходит деление на 0. Для этого необходимо скомпилировать программу с нужным флагом. Снова запустите программу под отладчиком, проанализируйте стек вызовов.

7. Что делать, если программа падает, но у Вас нет входных данных, на которых это происходит?
Включите запись coredump. Затем запустите скрипт compute.sh.
С помощью отладчика найдите строку в программе, в которой произошла ошибка. Проанализируйте стек вызовов, найдите причину ошибки.

8. Исправьте ошибки: найденные в пунктах 6 и 7. Напишите два юнит-теста, проверяющих, что ошибки исправлены.

Получившиеся файлы my_bc.cpp, evaluator.cpp, evaluator.h, bc_test.cpp отправьте в систему Ejudje.

9. Дополнительное задание на LD_PRELOAD. Переопределить функцию проверки пароля, чтобы программа принимала любой пароль.

# Вопросы

1. Вам даны файлы:

a.cpp
b.cpp
c.h

Напишите последовательность команд, которая создаст из этих файлов один исполняемый файл.

2. *Описать ситуацию, спросить какую линковку использовать. Варианты -- статическая или динамическая библиотеки.*

3. Почему для отладки по core-файлу необходим исполняемый файл?
