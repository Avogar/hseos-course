## Цель семинара
  * Понять: общую схему трансляции и запуска программ в операционной системе.
  * Научиться: компиляции и сборке программ на C++, состоящих из одного или нескольких файлов; отладке программ в среде Linux.

## Содержание семинара
  1. Исполняемый файл, запуск исполняемого файла операционной системой.
  2. Компиляция .cpp -> .o. Флаги компиляции.
  3. Препроцессор, заголовочные файлы, директива #include.
  4. Компоновка (линковка) исполняемого файла. Использование динамических и статических библиотек.
  5. Отладка программы с помощью gdb. Точки останова (breakpoints). Способы запуска отладчика.
  6. ~~Гадание~~ Отладка по coredump.

## Теоретическая справка

Процесс компиляции C/C++ можно условно разбить на 3 фазы:
1. Препроцессинг. На этой фазе обрабатываются *директивы препроцессора* - строки файла, начинающиеся с символа `#`. Две основные директивы:
  * `#include "file.h"` - заменяется на содержимое файла `file.h`. Важно понимать, что `#include` всего лишь подставляет
  один файл в другой. Например, если подключить один и тот же файл 2 раза, это скорее всего приведёт к ошибкам компиляции.
  Для решения этой проблемы применяются include guards или деректива `#pragma once`.
  * `#define FOO bar` - заменяет все встречи строки символов `FOO` в файле, на строку `bar`.
  Пример:
  ```
  // math.h
  #define PI 3.1415

  double sin(double x);
  // math.cpp
  #include "math.h"

  double cos(double x) {
      return sin(x + PI / 2);
  }
  // math.cpp после обработки препроцессором
  double sin(double x);

  double cos(double x) {
      return sin(x + 3.1415);
  }
  ```

  **Важно**: использование `#define`-ов (макросов) в C++ является признаком плохого кода, так как макросы ухудшают читаемость кода.

2. Компиляция (трансляция). На этой фазе, выход препроцессора преобразуется в машинный код. Результатом компиляции являются
  *объектные файлы*.

  Чтобы скомпилировать файл, нужно выполнить команду `g++ my_file.cpp -c -o my_file.o`.
  * `-o my_file.o` - результат компиляции нужно записать в файл `my_file.o`.
  * `-c` - только компилировать. Без этой опции gcc попытается сразу сделать исполняемый файл.

  Компилятору можно передавать дополнительные флаги, например:
  * `-Wall` - печатать предупреждения, об опасных конструкциях в коде.
  * `-O2` - включить оптимизации. По умолчанию код собирается без оптимизаций. Код, собраный с оптимизациями работает значительно быстрее.
  * `-fPIC` - собрать Positional Independent Code. Необходимо для сборки shared библиотек.
  * `-std=c++11` - включить стандарт C++11.
  * `-g` - добавляет в выходной файл отладочную информацию.
  * `-Ipath` - добавляет путь `path` в список путей поиска заголовочных файлов.

3. Линковка (связывание). На этом этапе объектные файлы объединяются в исполняемый файл или shared библиотеку.

**TODO:** компиляция исполняемого файла, использование static библиотек.

**TODO:** картинка про стадии компиляции.

**TODO:** рассказать про gdb.

## Задание

0. Склонируйте репозиторий http://github.com/hseos/sem-03.git.

1. В файле `bc.cpp` реализован калькулятор арифметических выражений. Он представляет из себя простой REPL (link to wiki).
  Сначала по входной строке строится дерево разбора (функция `Parse()`), затем это дерево вычислется (фукция `Eval()`).
  В файле `ast.h` находятся определения структур, из которых состоит дерево разбора (**не путать с деревом поиска!**).

  Скомпилируйте файл `bc.cpp` и запустите получившийся исполняемый файл. Вычислите значение выражения 1 + 2 * 3.

  *Note: В калькуляторе используется класс `std::unique_ptr`, появивившийся в стандарте c++11. Чтобы файл скомпилировался,
  нужно указать компилятору опцию `-std=c++11`.*

  *Note: Для выхода из калькулятора используйте сочетание клавиш Ctrl+C.*

2. Логику работы необходимо отделить от обработки входных данных и вывода результата и выделить в отдельный файл.
  Поместите функции `Parse()` и `Eval()` в файл `calc.cpp` и прототипы этих функций в `calc.h`. Скомпилируёте файлы `calc.cpp` и `bc.cpp` в
  один исполняемый файл. Убедитесь, что калькулятор запускается.

3. В файле `calc_test.cpp` находятся юнит-тесты. Тесты используют библиотеку gtest.
  Скомпилируйте файлы `calc_test.cpp` и `calc.cpp` вместе с библиотекой `gtest/libgtest.a` в один исполняемый файл. Запустите тесты,
  убедитесь что они проходят.

  *Note: Библиотека gtest использует системную библиотеку pthread. Чтобы подключить её, нужно добавить флаг -lpthread.*

5. Запустите исполняемый файл и вычислите значение выражения 42 / 0. Что произошло с программой?
  Запустите программу под отладчиком и снова вычислите значение выражения 42 / 0. Можете ли Вы найти строку программы, в которой происходит ошибка?

  Пересоберите калькулятор с отладочной информацией, снова запустите программу под отладчиком. Найдите строчку в программе, на которой происходит ошибка.

  Измените программу так, чтобы вместо деления на ноль она бросала исключение. Добавьте тест, проверяющий что программа больше не падает.

7. Что делать, если программа падает, но у вас нет входных данных, на которых это происходит?
  Включите запись coredump (`ulimit -c unlimited`). Затем запустите скрипт compute.sh.
  Запустите отладчик на получившимся core файле. Найдите строчку в программе, на которой произошла ошибка.
  Исправьте ошибку. Добавьте тест, проверяющий что ошибка исправлена.

**TODO:** инструкция по сдаче лабы на автоматическую проверку.

**TODO:** дополнительное задание на LD_PRELOAD. Переопределить функцию проверки пароля, чтобы программа принимала любой пароль.

## Вопросы

1. Напишите команду, которая скомпилирует файлы `a.cpp`, `a.h` и `b.cpp` в один исполняемый файл.
2. Почему нельзя скомпилировать файлы bc.cpp calc.cpp и bc_test.cpp в один исполняемый файл?
3. Можно ли линковать вместе объектные файлы, собранные с разными уровнями оптимизации?
4. Почему нельзя писать тело функции в заголовочном файле?
5. В чем преимущество отладки по coredump-у перед отладкой работающего процесса? В чем состоят недостатки?
6. Можно ли include-ить .cpp файлы?
7. Должен ли .h файл содержать синтаксически корректную программу?
